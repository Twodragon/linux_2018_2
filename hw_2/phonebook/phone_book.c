#include <linux/init.h>#include <linux/module.h>#include <linux/kernel.h>#include <linux/fs.h>#include <asm/uaccess.h>#include <linux/list.h>#include <linux/slab.h>#include <linux/uaccess.h>#include <linux/fs.h>#define DEVICE_NAME "module_1"#define START_MSG "Hello!\n"#define MSG_BUFFER_LEN 150static int device_open(struct inode *, struct file *);static int device_release(struct inode *, struct file *);static ssize_t device_read(struct file *, char *, size_t, loff_t *);static ssize_t device_write(struct file *, const char *, size_t, loff_t *);static struct file_operations file_ops = {	.read = device_read,	.write = device_write,	.open = device_open,	.release = device_release};struct phone_book_list{	struct list_head list;	char *name;	char *surname;	char *age;	char *phone_number;	char *mail_address;};static int major_num;static int device_open_count = 0;static char msg_buffer[150];static struct phone_book_list phone_book;static struct phone_book_list *tmp;static struct list_head *pos, *q;static char command[3];static char name[12];static char surname[23];static char age[3];static char phone_number[20];static char mail_address[50];static char rest_of_the_string[147];static ssize_t device_read(struct file *flip, char *buffer, size_t len, loff_t *offset) {	return simple_read_from_buffer(buffer, len, offset, msg_buffer, MSG_BUFFER_LEN);	}static ssize_t device_write(struct file *flip, const char *buffer, size_t len, loff_t *offset) {	strncpy(command, buffer, 3);	strncpy(rest_of_the_string, buffer+3, 147);
    	if (!strncmp(command, "add", 3)) {        	sscanf(rest_of_the_string, "%s %s %s %s %s", name, surname, age, phone_number, mail_address);
		tmp = (struct phone_book_list *)kmalloc(sizeof(struct phone_book_list), GFP_KERNEL);		tmp->name = name;		tmp->surname = surname;		tmp->age = age;		tmp->phone_number = phone_number;		tmp->mail_address = mail_address;
		list_add(&(tmp->list), &(phone_book.list));
        	sprintf(msg_buffer, "ADDED!\nname: %s\nsurname: %s\nage: %s\nphone_number: %s\nmail_address: %s\n", name, surname, age, phone_number, mail_address);	}
	else if (!strncmp(command, "rm", 2)) {		char deleted = 0;
		sscanf(rest_of_the_string, "%s", surname);
		list_for_each(pos, &phone_book.list){			tmp = list_entry(pos, struct phone_book_list, list);
			if (!strncmp(tmp->surname, surname, 23)){				sprintf(msg_buffer, "REMOVED!\nname: %s\nsurname: %s\nage: %s\nphone_number: %s\nmail_address: %s\n", tmp->name, tmp->surname, tmp->age, tmp->phone_number, tmp->mail_address);
				list_del(pos);			 	kfree(tmp);				deleted = 1;				break;			}		}		if (!deleted) {			sprintf(msg_buffer, "COULD NOT REMOVE!\nNo entry with surname: %s", surname); 		}	}	else if (!strncmp(command, "get", 3)) {		char found = 0;
		sscanf(rest_of_the_string, "%s", surname);
		list_for_each(pos, &phone_book.list){			tmp = list_entry(pos, struct phone_book_list, list);			if (!strncmp(tmp->surname, surname, 23)){				sprintf(msg_buffer, "GOT!\nname: %s\nsurname: %s\nage: %s\nphone_number: %s\nmail_address: %s\n", tmp->name, tmp->surname, tmp->age, tmp->phone_number, tmp->mail_address);				found = 1;				break;			}		}		if (!found) {			sprintf(msg_buffer, "COULD NOT GET!\nNo entry with surname: %s\n", surname); 		}	} 	return MSG_BUFFER_LEN;}static int device_open(struct inode *inode, struct file *file) { 	/* If device is open, return busy */ 	if (device_open_count) { 	return -EBUSY; 	} 	device_open_count++; 	try_module_get(THIS_MODULE); 	return 0;}static int device_release(struct inode *inode, struct file *file) { 	device_open_count--; 	module_put(THIS_MODULE); 	return 0;}
static int __init phone_book_init(void) { 	major_num = register_chrdev(0, "phone_book", &file_ops);
 	if (major_num < 0) { 		printk(KERN_ALERT "Could not register device: %d\n", major_num); 		return major_num; 	} else {	 	strncpy(msg_buffer, START_MSG, MSG_BUFFER_LEN);		INIT_LIST_HEAD(&phone_book.list);		printk(KERN_INFO "phone_book module loaded with device major number %d\n", major_num);	return 0;	}}static void __exit phone_book_exit(void) {	if (list_empty(&phone_book.list)){		list_for_each_safe(pos, q, &phone_book.list){			 tmp = list_entry(pos, struct phone_book_list, list);			 list_del(pos);			 kfree(tmp);		}	}
 	unregister_chrdev(major_num, DEVICE_NAME); 	printk(KERN_INFO "Goodbye, World!\n");}module_init(phone_book_init);module_exit(phone_book_exit);